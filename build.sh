#!/bin/bash
# FastEnhancer-Tiny WASM SIMD build script
#
# Usage: bash build.sh
#
# Output: fastenhancer-worklet.js (WASM inlined, AudioWorklet integrated)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="$SCRIPT_DIR/src"
WEIGHT_FILE="$SCRIPT_DIR/weights/fe_tiny.bin"
OUTPUT_FILE="$SCRIPT_DIR/fastenhancer-worklet.js"
LOADER_FILE="$SCRIPT_DIR/fe-loader.js"

echo "=== FastEnhancer-Tiny WASM SIMD Build ==="

# =============================================================================
# Emscripten setup
# =============================================================================
echo ""
echo "[1/4] Checking Emscripten..."
if ! command -v emcc &> /dev/null; then
    EMSDK_DIR="$HOME/emsdk"

    if [ -d "$EMSDK_DIR" ]; then
        echo "  -> Found emsdk: $EMSDK_DIR"
    else
        echo "ERROR: emcc not found. Please install Emscripten."
        exit 1
    fi

    cd "$EMSDK_DIR"
    ./emsdk install latest 2>/dev/null || true
    ./emsdk activate latest 2>/dev/null || true
    source ./emsdk_env.sh
    cd "$SCRIPT_DIR"
fi
echo "  -> emcc version: $(emcc --version | head -1)"

# =============================================================================
# Weight file check
# =============================================================================
echo ""
echo "[2/4] Checking weight file..."
if [ ! -f "$WEIGHT_FILE" ]; then
    echo "ERROR: Weight file not found: $WEIGHT_FILE"
    echo "       Run export_weights.py first."
    exit 1
fi
WEIGHT_SIZE=$(wc -c < "$WEIGHT_FILE" | tr -d ' ')
echo "  -> Weights: $WEIGHT_FILE ($WEIGHT_SIZE bytes)"

# =============================================================================
# WASM build
# =============================================================================
echo ""
echo "[3/4] Building WASM SIMD..."

C_FILES="$SRC_DIR/fastenhancer.c \
         $SRC_DIR/api.c \
         $SRC_DIR/simd.c \
         $SRC_DIR/fft.c \
         $SRC_DIR/stft.c \
         $SRC_DIR/conv.c \
         $SRC_DIR/gru.c \
         $SRC_DIR/attention.c \
         $SRC_DIR/activations.c"

emcc -O3 \
    -msimd128 \
    -mrelaxed-simd \
    -flto \
    -ffast-math \
    -fno-exceptions \
    -fno-rtti \
    -fomit-frame-pointer \
    -fmerge-all-constants \
    -fno-math-errno \
    -funsafe-math-optimizations \
    -ffinite-math-only \
    -fno-trapping-math \
    -DNDEBUG \
    -sWASM=1 \
    -sSINGLE_FILE=1 \
    -sMODULARIZE=1 \
    -sEXPORT_NAME="createFEModule" \
    -sEXPORTED_FUNCTIONS=_fe_init,_fe_run,_fe_free,_malloc,_free \
    -sEXPORTED_RUNTIME_METHODS=HEAPF32,HEAPU8 \
    -sALLOW_MEMORY_GROWTH=0 \
    -sINITIAL_MEMORY=16777216 \
    -sSTACK_SIZE=524288 \
    -sMALLOC=emmalloc \
    -sFILESYSTEM=0 \
    -sASSERTIONS=0 \
    -sENVIRONMENT=web,worker \
    -sSUPPORT_LONGJMP=0 \
    -sDISABLE_EXCEPTION_CATCHING=1 \
    --no-entry \
    $C_FILES \
    -o "$LOADER_FILE"

echo "  -> Loader size: $(wc -c < "$LOADER_FILE" | tr -d ' ') bytes"

# =============================================================================
# Generate worklet file
# =============================================================================
echo ""
echo "[4/4] Generating worklet file..."

# Encode weights as Base64
WEIGHT_B64=$(base64 < "$WEIGHT_FILE" | tr -d '\n')
echo "  -> Weight Base64: ${#WEIGHT_B64} chars"

cat > "$OUTPUT_FILE" << 'WORKLET_HEADER'
/**
 * FastEnhancer WASM SIMD AudioWorklet Processor
 * 16kHz, 16ms frame, streaming noise suppression
 * Auto-generated by build.sh
 */

// ============================================================================
// Polyfills for AudioWorkletGlobalScope
// ============================================================================

const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;

globalThis.atob = globalThis.atob || function (string) {
    string = String(string).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(string))
        throw new TypeError("Failed to execute 'atob'");
    string += "==".slice(2 - (string.length & 3));
    let bitmap, result = "", r1, r2, i = 0;
    for (; i < string.length; ) {
        bitmap =
            (b64.indexOf(string.charAt(i++)) << 18) |
            (b64.indexOf(string.charAt(i++)) << 12) |
            ((r1 = b64.indexOf(string.charAt(i++))) << 6) |
            (r2 = b64.indexOf(string.charAt(i++)));
        result +=
            r1 === 64
                ? String.fromCharCode((bitmap >> 16) & 255)
                : r2 === 64
                ? String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255)
                : String.fromCharCode((bitmap >> 16) & 255, (bitmap >> 8) & 255, bitmap & 255);
    }
    return result;
};

globalThis.self = globalThis.self || { location: { href: "" } };

if (typeof performance === "undefined") {
    globalThis.performance = { now: () => Date.now() };
}
if (typeof Date.now !== "function") {
    Date.now = function() { return new Date().getTime(); };
}

// ============================================================================
// Emscripten WASM Loader (SINGLE_FILE)
// ============================================================================

WORKLET_HEADER

# Append Emscripten loader
cat "$LOADER_FILE" >> "$OUTPUT_FILE"

# Append weight data + processor code
cat >> "$OUTPUT_FILE" << WORKLET_WEIGHTS

// ============================================================================
// Embedded Model Weights (Base64)
// ============================================================================

const FE_WEIGHTS_B64 = "${WEIGHT_B64}";

WORKLET_WEIGHTS

cat >> "$OUTPUT_FILE" << 'WORKLET_PROCESSOR'

// ============================================================================
// Constants
// ============================================================================

const FE_HOP_SIZE = 256;       // 16ms @ 16kHz
const FE_SAMPLE_RATE = 16000;
const INT16_SCALE = 32767;
const POOL_MASK = 3;

// ============================================================================
// Base64 → Uint8Array decoder
// ============================================================================

function b64ToUint8(b64str) {
    const raw = atob(b64str);
    const arr = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
    return arr;
}

// ============================================================================
// FastEnhancer Processor
// ============================================================================

class FEProcessor {
    constructor(wasm, weightBytes) {
        this.wasm = wasm;

        // Copy weights to WASM heap
        const weightPtr = wasm._malloc(weightBytes.length);
        wasm.HEAPU8.set(weightBytes, weightPtr);

        // Initialize (loads weights + creates engine)
        const ret = wasm._fe_init(weightPtr, weightBytes.length);
        if (ret !== 0) throw new Error('fe_init failed');

        // Weight data must remain alive (engine holds pointers into it)
        this.weightPtr = weightPtr;

        // Allocate I/O buffers on WASM heap
        this.inPtr = wasm._malloc(FE_HOP_SIZE * 4);
        this.outPtr = wasm._malloc(FE_HOP_SIZE * 4);
    }

    process(samples) {
        this.wasm.HEAPF32.set(samples, this.inPtr >> 2);
        this.wasm._fe_run(this.inPtr, this.outPtr);
        const off = this.outPtr >> 2;
        return this.wasm.HEAPF32.subarray(off, off + FE_HOP_SIZE);
    }
}

// ============================================================================
// AudioWorklet
// ============================================================================

const FEWorklet_Name = "FastEnhancerProcessor";

class FastEnhancerWorklet extends AudioWorkletProcessor {
    constructor(options) {
        super();

        const opts = options?.processorOptions || {};
        this.bufSize = opts.bufferSize || 3200;

        // Accumulation buffer for 256-sample frames
        this.accumBuf = new Float32Array(FE_HOP_SIZE);
        this.accumIdx = 0;

        // PCM output buffer
        this.pcmBuf = new Float32Array(this.bufSize);
        this.pcmIdx = 0;

        // Int16 buffer pool (zero-GC)
        this.pool = [];
        this.views = [];
        for (let i = 0; i < 4; i++) {
            const ab = new ArrayBuffer(this.bufSize * 2);
            this.pool[i] = ab;
            this.views[i] = new Int16Array(ab);
        }
        this.poolIdx = 0;

        // Performance monitoring
        this.perfCount = 0;
        this.perfTotal = 0;
        this.perfMax = 0;

        this.proc = null;
        this.ready = false;

        this.port.postMessage({ type: 'init', sampleRate: FE_SAMPLE_RATE });
        this._init();
    }

    async _init() {
        try {
            const wasm = await createFEModule();
            const weightBytes = b64ToUint8(FE_WEIGHTS_B64);
            this.proc = new FEProcessor(wasm, weightBytes);
            this.ready = true;
            this.port.postMessage('ready');
        } catch (e) {
            this.port.postMessage({ type: 'error', message: e.message });
        }
    }

    process(inputs) {
        const inData = inputs[0]?.[0];
        if (!inData || !this.ready) return true;

        // Accumulate blocks into 256-sample frames
        const remaining = FE_HOP_SIZE - this.accumIdx;

        if (inData.length <= remaining) {
            this.accumBuf.set(inData, this.accumIdx);
            this.accumIdx += inData.length;
        } else {
            for (let i = 0; i < remaining; i++) {
                this.accumBuf[this.accumIdx + i] = inData[i];
            }
            this.accumIdx = FE_HOP_SIZE;
        }

        if (this.accumIdx >= FE_HOP_SIZE) {
            const t0 = Date.now();
            const denoised = this.proc.process(this.accumBuf);
            const elapsed = Date.now() - t0;

            this.perfTotal += elapsed;
            this.perfCount++;
            if (elapsed > this.perfMax) this.perfMax = elapsed;

            if (this.perfCount >= 100) {
                const avgMs = this.perfTotal / this.perfCount;
                const rtf = this.perfTotal / 1600; // 100 frames × 16ms
                this.port.postMessage({
                    type: 'perf',
                    avg: avgMs,
                    max: this.perfMax,
                    rtf: rtf,
                    count: this.perfCount
                });
                this.perfTotal = 0;
                this.perfCount = 0;
                this.perfMax = 0;
            }

            this._appendPCM(denoised);

            this.accumIdx = 0;
            const overflow = inData.length - remaining;
            if (overflow > 0) {
                for (let i = 0; i < overflow; i++) {
                    this.accumBuf[i] = inData[remaining + i];
                }
                this.accumIdx = overflow;
            }
        }

        return true;
    }

    _appendPCM(samples) {
        const buf = this.pcmBuf;
        const len = samples.length;
        let idx = this.pcmIdx;

        for (let i = 0; i < len; i++) {
            buf[idx++] = samples[i];
            if (idx >= this.bufSize) {
                this._send();
                idx = 0;
            }
        }
        this.pcmIdx = idx;
    }

    _send() {
        const buf = this.pcmBuf;
        const len = this.bufSize;
        let pidx = this.poolIdx;

        let ab = this.pool[pidx];
        let int16 = this.views[pidx];

        if (ab.byteLength === 0) {
            ab = new ArrayBuffer(len * 2);
            int16 = new Int16Array(ab);
            this.pool[pidx] = ab;
            this.views[pidx] = int16;
        }

        for (let i = 0; i < len; i += 8) {
            let v0 = (buf[i]   * INT16_SCALE) | 0;
            let v1 = (buf[i+1] * INT16_SCALE) | 0;
            let v2 = (buf[i+2] * INT16_SCALE) | 0;
            let v3 = (buf[i+3] * INT16_SCALE) | 0;
            let v4 = (buf[i+4] * INT16_SCALE) | 0;
            let v5 = (buf[i+5] * INT16_SCALE) | 0;
            let v6 = (buf[i+6] * INT16_SCALE) | 0;
            let v7 = (buf[i+7] * INT16_SCALE) | 0;

            int16[i]   = v0 > 32767 ? 32767 : v0 < -32767 ? -32767 : v0;
            int16[i+1] = v1 > 32767 ? 32767 : v1 < -32767 ? -32767 : v1;
            int16[i+2] = v2 > 32767 ? 32767 : v2 < -32767 ? -32767 : v2;
            int16[i+3] = v3 > 32767 ? 32767 : v3 < -32767 ? -32767 : v3;
            int16[i+4] = v4 > 32767 ? 32767 : v4 < -32767 ? -32767 : v4;
            int16[i+5] = v5 > 32767 ? 32767 : v5 < -32767 ? -32767 : v5;
            int16[i+6] = v6 > 32767 ? 32767 : v6 < -32767 ? -32767 : v6;
            int16[i+7] = v7 > 32767 ? 32767 : v7 < -32767 ? -32767 : v7;
        }

        this.port.postMessage({ type: 'pcm', data: ab }, [ab]);
        this.poolIdx = (pidx + 1) & POOL_MASK;
        this.pcmIdx = 0;
    }
}

registerProcessor(FEWorklet_Name, FastEnhancerWorklet);
WORKLET_PROCESSOR

# Cleanup
rm -f "$LOADER_FILE"

echo ""
echo "=== Build complete! ==="
ls -lh "$OUTPUT_FILE"
